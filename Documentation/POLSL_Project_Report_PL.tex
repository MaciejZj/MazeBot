\documentclass[11pt]{article}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, margin=27mm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{slantsc}

\usepackage{caption}
\usepackage[newfloat]{minted}
\captionsetup[listing]{position=top}
\setminted{autogobble}

\usepackage{xcolor}
\definecolor{commentgreen}{RGB}{2,112,10}
\definecolor{eminence}{RGB}{108,48,130}
\definecolor{weborange}{RGB}{80,60,60}
\definecolor{frenchplum}{RGB}{129,20,83}

\usepackage{siunitx}
\usepackage[european,cuteinductors,fetbodydiode]{circuitikz}

\usetikzlibrary{calc}
\ctikzset{bipoles/thickness=1}
\ctikzset{bipoles/length=0.8cm}
\tikzstyle{every node}=[font=\small]
\tikzstyle{every path}=[line width=0.8pt,line cap=round,line join=round]

\graphicspath{ {.//} }
\author{Maciej Ziaja \and Bartosz Staszulonek}
\date{\today}

\begin{document}
\pagenumbering{gobble}
\title{
  Projekt Systemy Mikroprocesorowe \\
  \large MazeBot \\
    Robot unikający przeszkód z regulacją napędu silników prądu stałego}

\maketitle

\newpage
\pagenumbering{arabic}
\tableofcontents
\newpage

\section{Wstęp}

\subsection{Abstrakt}
Projekt polegał na budowie mobilnego robota, który unika przeszkód.
Konstrukcja porusza się na dwóch kołach, wykrywa przeszkody za pomocą czujnika ultradźwiękowego zamocowanego na wieży serwomechanizmu.
Platforma robota napędzana jest za pomocą pary silników prądu stałego, których kąt obrotu jest odczytywany przez robota za pomocą czujników szczelinowych.
W celu zwiększenia precyzji działania układu zbudowano układy regulacji prędkości silników.
Wykonano dwa typy układ regulacji, synchronizujący prędkość obrotu obu silników w~celu zachowania kierunku jazdy na wprost oraz kaskadowy układ regulacji skrętu platformy robota.
Układ regulacji skrętu robota przypomina zasadą działania prosty serwomechanizm.
Przedstawiono metodę identyfikacji i~strojenia regulatorów.
Na potrzeby projektu wykonano także schemat układu elektronicznego i~zrealizowano go w~postaci obwodu drukowanego PCB.
Zaprojektowano także podwozie robota i~wydrukowano je w~technologii~3D.

\subsection{Cel i zakres projektu}
Projekt obejmował budowę platformy bazującej na mikroprocesorze z~serii ATmega32, obsługującym peryferia:
\begin{itemize}
	\item czujnika ultradźwiękowego wykrywającego przeszkody,
	\item wieży serwomechanizmu, na której zamontowany jest czujnik i która kieruje go w różne strony,
	\item silników prądu stałego stanowiących napęd platformy
	\item czujników szczelinowych odczytujących kąt obrotu osi kół platformy,
	\item odbiornika podczerwieni pozwalającego na wyłączenie robota pilotem jeśli ten się oddali.
\end{itemize}
Współpraca tych komponentów pozwala robotowi na unikanie przeszkód.
Działanie robota powinno polegać na~jeździe przed siebie do~czasu napotkania przeszkody.
W momencie wykrycia przeszkody robot powinien się zatrzymać, a~następnie zbadać czy w~jego otoczeniu znajduje się niezagrodzona droga i~skierować się na~nią.
Prototyp wykonano z~użyciem układu Arduino Leonardo.
Przeprowadzono testy współpracy komponentów i~wyciągnięto wnioski dotyczące budowy finalnej konstrukcji.
Na podstawie testów określono parametry elementów finalnej konstrukcji.
Działanie prototypu prowadziło do następujących decyzji projektowych, które podyktowały dalszy tok projektu i~jego zakres:
\begin{itemize}
	\item w celu wydajnego wykorzystania przestrzeni na platformie zdecydowano się na wykonanie własnego układu elektronicznego i obwodu drukowanego,
	\item zaprojektowano własne podwozie dopasowane do używanych peryferiów,
	\item wykonano układy regulacji jazdy na wprost oraz skręcania platformy.
\end{itemize}

\section{Organizacja projektu}
\subsection{Harmonogram}
Projekt należało zrelaizować w przeciągu 4 miesięcy.
Proces jego wykonania składał się z dwóch części: testów komponentów wraz z budową prototypu oraz konstrukcji finalnego układu na podstawie wniosków wyciągniętych z testów konstrukcji prototypowej.
	Tabela \ref{tab:schedule} przedstawia ramowy rozkład pracy w czasie.

\begin{table}[hbt]
	\centering
	\label{tab:schedule}
		\begin{tabular}{|c|c|}
	\hline
Termin                  & Zakres pracy                                                                         \\ \hline
01.10.2018 - 20.10.2018 & Zebranie komponentów układu, ustalenie zakresu prac                                  \\ \hline
20.10.2018 - 01.11.2018 & Test komponentów i~peryferiów z użyciem Arduino Leonardo                             \\ \hline
01.11.2018 - 14.11.2018 & Budowa prototypu, programowanie głównej logiki programu \\ \hline
14.11.2018 - 01.12.2018 & Projekty obwodu drukowanego PCB i~podwozia                                           \\ \hline
01.12.2018 - 20.12.2018 & Synteza i~oprogramowanie układów regulacji                                           \\ \hline
20.12.2018 - 01.01.2019 & Złożenie układu finalnego                                                            \\ \hline
01.01.2019 - 20.01.2019 & Strojenie układów regulacji, budowa dokumentacji                                      \\ \hline
\end{tabular}
	\caption{Harmonogram pracy}
\end{table}

\subsection{Budżet}

\section{Budowa prototypu, analiza problemów}
Realizację projektu zaczęto od zgromadzenia peryferiów koniecznych do realizacji robota.
W pierwszej fazie prototypowania komponenty testowano osobno używając Arduino Leonardo. Zapoznano się z ich praktycznymi możliwościami i działaniem dostępnych bibliotek. 

Następnie połączono wszystkie komponenty jednocześnie i przeprowadzono ich jednoczesne testy oraz zmierzono zasilanie używając multimetru i zasilacza regulowanego.
Testy pokazały, że układ przy zasilaniu $ 7.3 \ V $~pobiera prąd do $ 0.3 \ A $,~co dostarcza nam informacji potrzebnych do doboru baterii dla robota.

Elementy prototypowe umieszczono na platformie testowej i oceniono działanie konstrukcji.
Okazało się, że działanie robota jest możliwe, ale sterowanie silnikami w~torze otwartym nie było wystarczająco precyzyjne aby unikać przeszkód. Przy symetrycznym wysterowaniu silników robot nie poruszał się w~kierunku prostym, różnice w działaniu poszczególnych silników są zbyt duże by pracowały one symetrycznie co jest wymagane by platforma jechała na wprost.
Skręcanie platformy o zadany kąt również okazało się nieprecyzyjne, obroty o~na przykład 90 stopni w~prawo były mało powtarzalne i~obarczone dużym błędem. Zdecydowano się na syntezę układów regulacji, aby wyeliminować te problemy.

Testy platformy prototypowej pokazały także, że złożoność układu jest zbyt duża aby budować go na płytce stykowej/prototypowej.
Dodatkowo serwomechanizm, który jest bardzo wrażliwy na zakłócenia zasilania, działał źle gdy był połączony przez wiele kabli, które razem tworzyły dużą rezystancję. Obserwacje te skłoniły nas do zaprojektowania własnego obwodu drukowanego, który mieściłby wszystkie potrzebne komponenty elektroniczne na małej przestrzeni.
Konstrukcja mechaniczna platformy prototypowej okazała się mało solidna i~nie była dostosowana do używanych przez nas modułów elektronicznych. W celu zwiększenia porządku i~wytrzymałości układu zdecydowano się na projekt własnego podwozia robota.

\section{Projekt układu elektronicznego}
\subsection{Działanie i uzasadnienie doboru elementów elektronicznych}
\subsubsection{Mikroprocesor ATmega32u4}
Centralnym elementem robota jest mikroprocesor AVR o architekturze RISC. Ośmiobitowe mikroprocesory ATmega są popularnym wyborem przy konstrukcji układów wbudowanych w przemyśle i urządzeniach elektronicznych o niedużym stopniu wymaganej wydajności.
Ich zaletą jest duża powszechność oraz fakt, że na procesorach z tej rodziny bazuje popularna platforma Arduino, w ramach której dostępny jest szeroki zakres bibliotek programistycznych do obsługi peryferiów. Przy wyborze konkretnego modelu mikroprocesora kierowaliśmy się następującymi kryteriami:
\begin{itemize}
	\item obsługa czterech przerwań zewnętrznych:
		\begin{enumerate}
			\item pochodzących z enkodera lewego koła,
			\item pochodzących z przerwań enkodera prawego koła,
			\item pochodzących z czujnika ultradźwiękowego,
			\item pochodzących z odbiornika podczerwieni, 
		\end{enumerate}
	\item obsługa trzech wyjść PWM, za pomocą liczników w celu:
		\begin{enumerate}
			\item sterowania prędkością lewego silnika prądu stałego,
			\item sterowania prędkością prawego silnika prądu stałego,
			\item sterowania położeniem serwomechanizmu, na którym zamontowany jest czujnik ultradźwiękowy,
		\end{enumerate}
	\item możliwość użycia sumarycznie dwunastu wejść wyjść cyfrowych do komunikacji z peryferiami,
	\item pożądana jest wbudowana obsługa komunikacji szeregowej za pomocą interfejsu USB w celu łatwego debugowania układu i zdjęcia pomiarów dynamiki układu przy identyfikacji obiektu regulacji i strojeniu regulatorów
	\item powyższe wymagania powinny być spełnione przy użyciu bootloadera i bibliotek Arduino.
\end{itemize}


Powyższe wymagania spełnia mikroprocesor ATmega32u4 firmy Atmel.
Jest to procesor na którym bazuje układ Arduino Leonardo, który wykorzystano przy konstrukcji prototypu.
Z użyciem bibliotek Arduino ATmega32u4 pozwala na używanie do pięciu przerwań zewnętrznych oraz siedmiu kanałów generujących sygnały PWM.
Istotne jest, że kanały PWM są obsługiwane przez cztery oddzielne liczniki. Biblioteki Arduino (szczególnie obsługi serwomechanizmu) wchodzą łatwo w konflikty i korzystają z liczników w sposób uniemożliwiający ich współdzielenie przy generowaniu sygnałów PWM.
Dlatego przy doborze mikroprocesora i wyborze jego wyprowadzeń starano się, aby serwomechanizm był obsługiwany przez oddzielny licznik.
Pin sterujący serwem nie powinien generować sygnałów z użyciem tego samego licznika co inne kanały PWM, aby uniknąć konfliktów bibliotek Arduino.
Wybrany model mikroprocesora jest dostępny tylko w obudowach powierzchniowych QFP (\textit{Quad Flat Package}), przy wyborze tej jednostki należy pamiętać, że wymaga ona umiejętności precyzyjnego lutowania. Procesor może pracować przy zasilaniu $ 5\ V $, jest to dla nas dogodne ponieważ reszta naszych peryferiów ma takie same napięcie zasilania.


\subsubsection{Silniki prądu stałego}
Ze względu na ograniczenia budżetowe zdecydowano się na jedne z najtańszych dostępnych silników, wyprodukowane przez firmę Dagu.
Silniki prądu stałego oferują największe momenty siły przy małych obrotach, nadają się dobrze do napędzania i przyspieszania platform robotów, oferują możliwość płynnego sterowania.
Ich wadą jest fakt, że bez dodatkowego układu czujników nie można określić ich kąta obrotu.
Ze względu na obecność komutatora i szczotek silniki prądu stałego zużywają się w czasie pracy.
Parametry wybranych przez nas silników są następujące:
\begin{itemize}
	\item maksymalne napięcie zasilania: $ 6\ V $,
	\item moment obrotowy: $ 0,8\ kg \cdot cm $, $ 0,78\ Nm $,
	\item obroty silnika bez obciążenia: $ (90 \pm 10) \ \frac{obr}{min} $,
	\item pobór prądu silnika bez obciążenia: $ 190\ mA\ (max.\ 250\ mA) $,
	\item pobór prądu silnika przy zatrzymanym wale: $ 1\ A $.
\end{itemize}
% TODO: compare with real
Do silników przymocowano koła o parametrach:
\begin{itemize}
	\item średnicy: $ 65\ mm $,
	\item szerokości: $ 30\ mm $.
\end{itemize}

\subsubsection{Sterownik silników prądu stałego -  mostek H}
Najbardziej popularnym sposobem sterowania silnikami prądu stałego jest użycie mostka H.
Jest to układ składający się z czterech tranzystorów polowych, których dreny i~źrodła są odpowiednio połączone z sterowanym silnikiem. Para tranzystorów połączona z~tą samą szczotką silnika ma złączone bramki, ale przeciwny stan otwarcia.
Złączone bramki są wyprowadzone z~układu i~stanowią wejścia sterowania. W~zależności od tego na które z~wejść podamy stan wysoki przez jeden z~tranzystorów z~każdej pary będzie płyną prąd, powodując obroty silnika w~odpowiednim kierunku.
Układem elektronicznym, który zawiera w sobie dwa mostki H, co pozwala na sterowanie parą silników, jest L298N.
Dodatkowo układ posiada dodatkowe tranzystory do sterowania prędkością silników za pomocą sygnału PWM, który stopniowo otwiera i~domyka tranzystor polowy przepuszczający sygnały wejściowe. Parametry sterownika są następujące:
\begin{itemize}
	\item maksymalne napięcie zasilania silników: $ 45\ V $,
	\item napięcie części logicznej: $ 4,5\ V - 7\ V $,
	\item maksymalny prąd zasilający silnik: $ 2\ A $.
\end{itemize}
Sterownik dostępny jest w obudowie przewlekanej Multiwatt15. Porównując parametry mostka H z silnikami możemy stwierdzić, że jest on wystarczający do ich wysterowania.

\subsubsection{Stabilizator napięcia L7805CV}
Wszystkie układy logiczne zasilane są napięciem $ 5\ V $, ale silniki zasilane są napięciem $ 7,3\ V $. 
Wynika stąd, że najlepiej zastosować baterię siedmiowoltową, a zasilanie do części logicznej dostarczać poprzez regulator napięcia. Najbardziej popularnym regulatorem jest układ 7805. 
W wersji CV jego parametry są następujące:
\begin{itemize}
	\item maksymalne napięcie wejściowe: $ 35\ V $,
	\item napięcie wyjściowe: $ 5\ V $ (z dokładnością $ 2\% $,
	\item maksymalny prąd wyjściowy: $ 1.5\ A $.
\end{itemize}
Stabilizator jest dostępny w różnych obudowach, przewlekanych i powierzchniowych, ze względu na łatwość montażu, dostępność i możliwość zamontowania radiatora wybraliśmy model w obudowie przewlekanej TO-220.
Po porównaniu parametrów stabilizatora z parametrami komponentów, które zasili można stwierdzić, że jest on wystarczający.

\subsubsection{Czujnik ultradźwiękowy}
Najbardziej popularnym i łatwo dostępnym czujnikiem odległości jest czujnik ultradźwiękowy HC-SR04.
Czujniki ultradźwiękowe mierzą odległość na podstawie czasu, który jest potrzebny fali ultradźwiękowej na dotarcie do przeszkody i powrót do czujnika po jej odbiciu.
Pomiar czujnikiem rozpoczyna się od podania na wejście TRIG stanu wysokiego przez $ 10 \mu s $. Powoduje to wygenerowanie przez czujnik ciągu ośmiu sygnałów ultradźwiękowych o częstotliwości $ 40\ kHz $. Po odbiciu sygnału od przeszkody i jego powrocie do czujnika odległość można obliczyć według wzoru \ref{eq:ultrasonic}, gdzie:

\begin{itemize}
	\item $ dist $ to odległość mierzona,
	\item $ Tim_h $ to czas trwania stanu wysokiego, 
	\item $ v_s $ to prędkość rozchodzenia się fali dźwiękowej w powietrzu, typowo $ 340 \frac{m}{s} $.
\end{itemize}
\begin{equation}
\label{eq:ultrasonic}
	dist = \frac{Tim_h \cdot v_s}{2}
\end{equation}
Model czujnika HC-SR04 charakteryzuje się następującymi parametrami:
\begin{itemize}
	\item napięcie zasilania: $ 5\ V $,
	\item średni pobór prądu: $ 15\ mA $,
	\item zakres pomiarowy: od $ 2\ cm $ do $ 200\ cm $,
	\item częstotliwość pracy: $ 40\ kHz $,
	\item wymiary: $ 45 \times 20 \times 15 mm $.
\end{itemize}
Zasilanie czujnika i zakres jego pracy są odpowiednie dla projektu.
Przeszkody które chcemy wykrywać będą znajdywały się w odległości parunastu centymetrów od robota.
Należy mieć na uwadze, że czujniki ultradźwiękowe najlepiej wykrywają duże przeszkody. 
Dodatkowo istotne jest, że pomiar czujnika ultradźwiękowego trwa w czasie, przebycie odpowiedniej drogi przez falę ultradźwiękową nie jest natychmiastowe.
Kwestia ta zostanie wzięta pod uwagę w czasie tworzenia oprogramowania.

\subsubsection{Serwomechanizm}
Aby umożliwić robotowi kierowanie czujnika odległości w różnych kierunkach, ten zamieszczono na wieży serwomechanizmu.
Ponieważ wymagamy aby czujnik mógł być skierowany w lewo, prawo oraz na wprost wystarczające jest serwo 180 stopni.
Waga czujnika ultradźwiękowego jest znikoma, dlatego serwomechanizm można wybrać kierując się jak najniższą ceną.

\subsubsection{Odbiornik podczerwieni TSOP4836}
Robota wyposażono w odbiornik podczerwieni ułatwiający jego zatrzymanie.
W celu łatwej współpracy z domowymi pilotami na podczerwień należało wybrać odbiornik wspierający popularne formaty: NEC Code, Toshiba Micom Format, Sharp Code, RC5 Code, RC6 Code, R–2000 Code...

Wybraliśmy odbiornik TSOP4836 pracujący z falami o częstotliwości $ 36\ kHz $. Zgodnie z dokumentacją % TODO
 odbiornika należy go zabezpieczyć kondensatorem filtrującym i rezystorem. Parametry odbiornika są następujące:
\begin{itemize}
	\item napięcie zasilania: od $ 4,5\ V $ do $ 5,5\ V $,
	\item średni pobór prądu: $ 1,5\ mA$.
\end{itemize}

\subsubsection{Elementy pasywne}
Użyte komponenty elektroniczne wymagają użycia kondensatorów filtrujących, zastosowano kondensatory o pojemnościach podanych w dokumentacjach filtrowanych elementów.
Kondensatory ceramiczne są umieszczone w obudowach przewlekanych, starano się dobrać kondensatory elektrolityczne w obudowach powierzchniowych, aby zredukować miejsce, którą zajmują.
Spis wszystkich elementów układu, w tym elementów pasywnych znajduje się w sekcji \ref{sec:schem}.
\subsection{Schemat układu elektronicznego}
\label{sec:schem}
Na rysunku %TODO
przedstawiono utworzony schemat układu elektronicznego.
Zastosowano przycisk, który zwiera pin reset z~ziemią, jeżeli przycisk jest przytrzymany dostatecznie długo zresetowany zostanie układ.
Aby podczas resetu nie doszło do zwarcia zasilania dodano rezystor R1. Układ resetu znajduje się w~polu B2 schematu.
Źródłem taktowania mikroprocesora jest zewnętrzny rezonator kwarcowy $ 16\ MHz $. Do jego poprawnego działania konieczne są odpowiednie kondensatory. Do osiągnięcia zamierzonego taktowania użyto kondensatorów o~pojemności $ 22\ pF $. Mikroprocesor zasilono napięciem $ 5\ V $, zasilanie filtrowane jest kondensatorami $ 100\ nF $, zasilanie portu USB filtrowane jest kondensatorami $ 1 \mu F $.
W polu A2 schematu umieszczono diody sygnalizacyjne.
Dioda PWR sygnalizuje obecność napięcia na wyjściu stabilizatora.
Diody TX, RX związane są z transmisją szeregową.
Diody podłączono tak że są aktywne kiedy wyjścia procesora są w trybie niskim.
Dzięki temu diody świecą kiedy transmisja szeregowa nie ma miejsca i sygnalizują tym samym jego poprawne działanie.
Jest to wygodne ponieważ dioda PWR mówi tylko o obecności zasilania, ale nie informuje użytkownika o poprawnym uruchomieniu układu.
Każda z diod podłączona jest przez odpowiedni rezystor.


W polu C1 znajduje się port USB w wersji MICRO. Linie portu szeregowego zabezpieczono dławikiem ferrytowym, oraz rezystorami.
Do programowania mikroprocesora zastosowano złącze ICSP sześciopinowe, znajdujące się w~polu D1 schematu.

W polu A5 schematu znajduje się mostek H L298.
Do jego wyjść silnikowych dodano diody prostownicze, łączące go z baterią zasilającą skierowane przeciwnie do polaryzacji baterii.
Na cewkach silników w czasie jego pracy gromadzi się energia w postaci pola magnetycznego.
Po zatrzymaniu silników i hamowaniu platformy energia to wróci do układu w postaci płynącego prądu.
Dzięki obecności diod układ mostka jest zabezpieczony przez tymi prądami, popłyną one przez diody do baterii, co więcej ze względu na polaryzację energia odzyskiwana z silników będzie ładować baterię, tworząc prosty układ aktywnego hamowania.
W sekcji \textsc{io ports} znajdują się złącza peryferiów układu.
Komponenty z fabrycznymi wyprowadzeniami przez goldpiny, połączono tak samo od strony układu.
Silniki i zasilanie są złączone przez konektory \textsc{arc}.


\subsection{Projekt układu drukowanego}
\subsubsection{Parametry techniczne układu drukowanego}
Ze względu na ograniczoną przestrzeń na powierzchni platformy robota zdecydowano się na wykonanie własnego obwodu drukowanego w technologii dwustronnej, z metalizowanymi otworami i solder maską.
W celu zachowania zgodności z procesem technologicznym producenta płytek % TODO
przyjęto następujące ustawienia \textsc{drc} (\textit{Design rules check}):
\begin{itemize}
	\item grubość laminatu wraz ze ścieżkami: $ 1.5\ mm $,
	\item grubość ścieżek: $ 0.035\ mm $,
	\item odległości między padami, przelotkami (\textit{via}) oraz ścieżkami: $ 6\ mil $,
	\item odległości ścieżek od krawędzi płytki: $ 40\ mil $,
	\item minimalna odległość otworów: $ 6\ mil $,
	\item minimalna szerokość ścieżki: $ 6\ mil $,
	\item minimalna średnica otworu: $ 0,35\ mm $,
	\item szerokość termoizolacji padów od wylewek (ułatwia lutowanie): $ 10\ mil $.
\end{itemize}
Przy tworzeniu płytki zastosowano technikę wylewki masy, tworzenia dużych płaszczyzn masy, zamiast prowadzenia poszczególnych ścieżek.
Ułatwia to rozmieszczenie połączeń i zmniejsza rezystancję ścieżek masy.
Zastosowano elementy zawierające ołów jako bardziej wytrzymałe i łatwiejsze w lutowaniu.
W amatorskim lutowaniu nie używa się temperatur przy których nie wydzielają się trujące opary ołowiu.


\subsubsection{Rozmieszczenie elementów na powierzchni układu drukowanego}
W centralnej części obwodu drukowanego umieszczono mikroprocesor.
Górną krawędź układu zajmują konektory peryferiów, dolna krawędź została przeznaczona na elementy służące interakcji z użytkownikiem.
Płytka została wykonana w technologii mieszanej, w celu zaoszczędzenia miejsca starano się używać elementów montowanych powierzchniowo, tam gdzie było to możliwe i wygodne.
Podczas prowadzenia ścieżek układu należy mieć na uwadze ich szerokość.
Znając parametry techniczne płytki oraz prądy płynące przez poszczególne ścieżki można obliczyć ich minimalną szerokość za pomocą kalkulatorów dostępnych online. %TODO: ref net
Obudowę rezonatora kwarcowego oddzielono od powierzchni obwodu wyciętą gumą.
Na obudowach elementów aktywnych umieszczono radiatory.
Rozdysponowanie wyprowadzeń sygnałowych mikroprocesora jest kompromisem między ograniczeniami bibliotek Arduino, możliwościami procesora oraz ilością miejsca dostępnego na płytce.

\section{Projekt podwozia robota}
W celu zwiększenia trwałości i solidności podwozia zdecydowano się zaprojektować własne oraz wydrukować je w technologii 3D.
Podwozie zaprojektowano tak aby osiągnąć jego modułowość.
Platforma robota składa się z osobnych części:
\begin{itemize}
	\item głównego podwozia z uchwytami na silniki,
	\item dwóch obudów na czujniki szczelinowe,
	\item uchwytu na serwomechanizm,
	\item elementu mocującego czujnik ultradźwiękowy na szczycie serwomechanizmu,
	\item obudowy baterii.
\end{itemize}
Obudowy komponentów są łączone z podwoziem śrubami. Jeżeli zaistniałaby potrzeba wymiany danego komponentu, np. serwomechanizmu, to wystarczy na nowo wydrukować jedynie nową obudowę na wymieniany komponent.
W obudowie uwzględniono utworzenie otworów oraz uchwytów na kable.
Bateria zasilająca układ jest połączona z obwodem przez przełącznik dwupozycyjny.

\section{Synteza układów regulacji}
Budowa i testy układu prototypowego wykazały, że bez zastosowania dodatkowych środków układ porusza się w sposób nieprecyzyjny.
Zdecydowano się na syntezę układów regulacji w celu poprawienia precyzji działania robota.
\subsection{Regulator synchronizacji prędkości silników}
Bez zastosowania układu regulacji robot nie porusza się prosto przy symetrycznym wysterowaniu lewego i prawego silnika.
Jest to spowodowane różnicami w wykonaniu poszczególnych silników, niesymetrycznym obciążeniem platformy oraz niedoskonałościami jej konstrukcji.
Problem ten można próbować rozwiązać następującymi sposobami:
\begin{itemize}
	\item wyważaniem platformy robota odpowiednimi odważnikami, jest to najgorsze rozwiązanie, nie daje pewnych wyników jest bardzo zależne od stopnia naładowania baterii, ponieważ silniki rozładowują się niesymetrycznie,
	\item sterowaniem PWM w otwartym torze, tak aby uwzględnić niesymetryczność silników, sterowanie należy ustalić drogą eksperymentalną, ta metoda również jest podatna na rozładowanie baterii oraz zmianę obciążenia platformy,
	\item konstrukcją regulatorów, które na podstawie odczytów z enkoderów szczelinowych synchronizują prędkość silników.
\end{itemize}

Ze względu na największą pewność efektów, niskie koszty oraz wartość edukacyjną zdecydowano się na rozwiązanie wykorzystujące układy regulacji.


Układ będzie miał na celu regulację prędkości silnika \textit{slave} na podstawie odczytu prędkości silnika \textit{master}. Dodatkowo silnik \textit{master} będzie regulowany ze stałą wartością zadaną prędkości w celu zapewnienia większej pewności jego pracy.
Regulator prędkości silnikami \textit{slave} powinien być \textsc{pid} lub \textsc{pi}.
Obecność członu całkującego jest wymagana aby osiągnąć odpowiednio wysoki astatyzm układu.
Dzięki temu członowi układ wyrówna nie tylko chwilową prędkość platformy, ale również sumaryczną przebytą przez robota drogę, co jest kluczowe aby utrzymać kierunek jazdy.
Dodatkowo obliczenia związane z członem całkującym są w naszym przypadku proste, ponieważ odczyt z enkoderów charakter drogi przebytej przez robota, czyli całki z prędkości.
Regulator prędkości silnika \textit{master} może być typu proporcjonalnego.
Zwiększanie astatyzmu tego silnika nie ma znaczenia dla jego poruszania się po lini prostej.
W regulatorach nie zastosowano członu różniczkującego, który nie jest konieczny, a utrudniałby konstrukcję układów i sprawiał wyzwania obliczeniowe.

Schemat % TODO
obrazuje konstrukcję planowanego układu regulacji prędkości silników.
Jest to wyjściowy schemat regulatora, natomiast nie jest dopasowany do charakteru toru pomiarowego i implementacji programistycznej.
Układ należy przekształcić w celu jego łatwiejszej implementacji.
Czujniki szczelinowe zwracają do układu pomiar liczby szczelin na tarczy enkodera co jest ekwiwalentem całki drogi, dlatego będziemy dążyć do usunięcia operacji całkowania z układu i bloku \textit{zamiana $ \alpha $ na $ \omega  $}.
Ilość zliczonych szczelin oznaczono na schemacie jako $ \alpha $, prędkość silników (ilość szczelin w czasie) oznaczono jako $ \omega $, silnik \textit{master} oznaczono indeksem \textit{m}, a silnik \textit{slave} indeksem \textit{s}.
W pierwszym kroku przekształceń układu skorzystamy z rozłączności operacji całkowania i przeniesiemy to działanie przed regulator oraz obliczymy całki sygnału i wartości zadanej osobno a, uchyb wyznaczymy z różnicy tych całek.
Układ po tym przekształceniu obrazuje schemat %TODO
W następnym kroku można zauważyć że blok \textit{zamiana $ \alpha $ na $ \omega  $} jest operacją różniczkowania, czyli mnożenia razy operator $ s $. Wynika z tego że możemy skrócić bloki całkowania $ \frac{1}{s} $ i różniczkowania $ s $.
Finalny projekt regulatora przedstawia schemat: % TODO
Schemat ten zawiera dodatkową modyfikację. Tarcze enkoderów wprowadzają do układu dyskretyzację oraz błąd kwantyzacji.
Silnik \textit{slave}, który nadąża za silnikiem \textit{master} zacznie się obracać po nim, a obrót od startu układu do pierwszej szczeliny silnika \textit{master} sprawia, że w układzie pojawia się błąd.
Błąd ten jest zależny od odległości punktu pomiarowego enkodera do pierwszej zliczonej szczeliny.
Pozycja punktu pomiaru w momencie startu robota jest losowa podobnie błąd z tego wynikający.
Aby zmniejszyć ten problem do układu zdecydowano się na element sterowania w torze otwartym narzucający punkt pracy regulatorów.
Dzięki temu w momencie startu oba silniki są wysterowane do jazdy na wprost.
Wartości punktu pracy dla obu silników należy wyznaczyć eksperymentalnie, są one zależne od niesymetryczności charakterystyk silników.


\subsection{Kaskadowy regulator skrętu platformy} \label{sec:reg_casc}
Kolejnym problemem jest zapewnienie powtarzalności i precyzji obrotów platformy robota.
W tym celu należy zbudować regulator położenia robota, którego wartością zadaną jest ilość zliczonych przez enkodery szczelin.
Ilość szczelin potrzebna do obrotu platformy o zadany kąt jest zależna od konstrukcji mechanicznej robota.

\begin{equation}
	\label{eq:slot_num}
	\alpha = round \left( \frac{\beta}{ \ang{360}} \cdot 2 \cdot \alpha_{disk} \cdot \frac{wheelbase}{d_w} \right)
\end{equation}
Opisuje ją wzór \ref{eq:slot_num}, gdzie:
\begin{itemize}
	\item liczba slotów potrzebnych do obrotu o zadany kąt to $ \alpha $,
	\item zadany kąt obrotu całej platformy robota to $ \beta $,
	\item liczba szczelin na tarczy enkodera to $ \alpha_{disk} $,
	\item rozstaw osi podwozia to $ wheelbase $,
	\item średnica kół to $ d_w $.
\end{itemize}
Wzór wynika z proporcji obrotu koła do obrotu całej platformy robota wokół osi przebiegającej przez jej środek.
We wzorze można zauważyć podwajanie liczby szczelin, wynika to z wyzwalania przerwania zliczania szczelin zarówno na zboczy rosnącym jak i malejącym w celu zwiększenia ich rozdzielczości.


Jeżeli w układzie zastosujemy regulator proporcjonalny z pojedynczą pętlą sprzężenia zwrotnego napotkamy na problem szczególnie widoczny przy obrotach o mały kąt przy dużych oporach ruchu.
Wtedy jeżeli regulator wyznaczy prędkość na podstawie uchybu ilości zliczonych slotów może się okazać, że wyznaczone wysterowanie jest zbyt małe aby poruszyć podwoziem silnika.
Dodane do regulatora członu całkującego spowoduje że po czasie, kiedy wartość uchybu całki będzie odpowiednio duża układ ruszy z miejsca.
Musimy jednak pamiętać, że układ regulacji położenia ma obiekt o charakterze całkującym (bo ilość zliczonych slotów jest ekwiwalentem drogi).
Regulacja z członem całkującym obiektów całkujących prowadzi do utworzenia niestabilnych układów regulacji % TODO
Rozwiązaniem tego problemu jest zastosowanie regulatora o strukturze kaskadowej, widocznego na rysunku % TODO
Regulator taki składa się z dwóch pętli sprzężenia, zewnętrznej i wewnętrznej oraz towarzyszącym im regulatorów odpowiednio położenia i prędkości.
Regulator położenia na podstawie uchybu liczby slotów ustala prędkość zadaną regulatora wewnętrznego potrzebną na wykonanie obrotu.
Regulator prędkości otrzymuje swoją wartość zadaną od regulatora położenia.
Regulator wewnętrzny, prędkości może zawierać człon całkujący, ponieważ nie reguluje samodzielnie układu całkującego.
Ponieważ pokonanie oporu ruchów przy starcie jest trudniejsze od kontynuowania rozpoczętego obrotu % TODO
to zdecydowano się na odwijanie całkowania (zerowanie) przy każdej zliczonej szczelinie.
Mogłoby to spowodować niepłynny ruch robota, natomiast sprawdzono eksperymentalnie, że obrane nastawy są wystarczające, aby człon proporcjonalny powodował płynny ruch obracającej się platformy, przy częstym zerowaniu członu całkującego.
Powoduje to też łagodne zatrzymanie robota, co sprzyja eliminowaniu poślizgów i minimalizuje wybieg silnika i przeregulowania.

\subsubsection{Wyznaczenie przedziału błędów w układzie.} \label{sec:err}
Układ nie jest wolny od błędów związanych z jego konstrukcją mechaniczną i implementacją rozwiązań.
Tarcza enkodera ze skończoną liczbą szczelin powoduje dyskretyzację działania układu i powoduje powstanie opóźnienia w synchronizacji silników \textit{master} i \textit{slave}.
Ponieważ błąd ten ma charakter błędu kwantyzacji można go łatwo oszacować.
Zgodnie z % TODO
błąd taki ma rozkład równomierny, jego skrajne wartości można wyliczyć według wzoru \ref{eq:err_max} gdzie:
\begin{itemize}
	\item liczba szczelin na tarczy enkodera to $ \alpha_{disk} $,
	\item liczbę szczelin podwojono, ponieważ przerwanie wyzwalane jest na obu zboczach w celach zwiększenia rozdzielczości enkodera.
\end{itemize}

\begin{equation}
	\label{eq:err_max}
	\Delta \alpha_{max} = \pm \frac{\ang{360}}{\alpha_{disk} \cdot 2} \cdot \frac{1}{2} = \pm \ang{4,5}
\end{equation}
Ponieważ rozkład szumu kwantyzacji jest równomierny prawdopodobieństwo błędu o każdej wartości z tego przedziału wynosi $ \frac{1}{q} $, gdzie: $ q = {\left( \frac{\ang{360}}{\alpha_{disk} \cdot 2} \right)} $.
Należy również pamiętać, że pętla sprzężenia zwrotnego i pomiar enkoderów nie obejmują prawdziwego położenia platformy, a jedynie obroty koła.
Wszelkie poślizgi powodują ruch który nie zostanie zarejestrowany przez enkodery.
Należy pamiętać, że silniki mają wybieg, to znaczy nie zatrzymują się natychmiastowo po wyłączeniu sterowania.
Duże wybiegi, przy dużych prędkościach będą powodować oscylacje w układzie skręcania.
Jest to niepożądane nie tylko ze względu na niską jakość regulacji, ale komplikuje oprogramowanie układu ponieważ enkodery nie wiedzą w którą stronę kręcą się silniki, a jedynie zliczają kolejne impulsy.
Dlatego przy strojeniu regulatora kluczowe jest aby dobrać nastawy gwarantujące brak oscylacji w układzie.
Dodatkowo podczas programowania ograniczono wartość prędkości zadanej wypracowywanej w regulatorze kaskadowym przez regulator położenia.
Zapobiega to zbyt gwałtownym startom platformy, z którymi mogłyby się wiązać poślizgi.

\subsection{Identyfikacja obiektu regulacji}
W celu poprawnego strojenia regulatorów należy zbudować model obiektu regulacji.
W naszym przypadku obiektami są dwa silniki prądu stałego.
Prostym sposobem identyfikacji obiektu jest podanie na jego wejście skoku jednostkowego i analiza uzyskanej odpowiedzi czasowej.
Eksperyment identyfikacyjny wykonano podając skok w postaci wysterowania silników wartością \textsc{pwm} równą $ 100 $.
Należy pamiętać, że z punktu widzenia układów regulacji, które utworzymy na odstawie identyfikacji ta wartość wysterowania będzie równa jedności.
Przy zadawaniu wartości silnikom sygnały będzie należało odpowiednio skalować.
Odpowiedź czasową na wymuszenie jednostkowe otrzymano przez komunikację poprzez port szeregowy USB.
Utworzono program testowy, który drukował przez port liczbę slotów i czas zliczeń.
Dane przekazywano komputerowi w formacie zgodnym z \textsc{csv} (\textit{comma separated value}), dzięki temu ich import do programu \textsc{matlab} mógł się odbyć w łatwy sposób.
Odpowiedź układu zarejestrowano dla silników bez obciążenia i dla silników pod obciążeniem podwozia.
Wyniki eksperymentu przedstawiają wykresy: %TODO


Ponieważ jako odpowiedź układu zliczano sloty, które są ekwiwalentem drogi należało spodziewać się odpowiedzi o charakterze całkującym.
Wyniki identyfikacji potwierdziły te przypuszczenia, wykresy przypominają odpowiedź układu o transmitancji całki z inercją.
Widać że przy obciążeniu silników platformą mają one większą bezwładność, czego również należało się spodziewać.
Zaprojektowane układy mają na celu regulację prędkości stąd odpowiedź należałoby zróżniczkować aby uzyskać odpowiedź prędkości w czasie.
Nie jest to jednak konieczne, zróżniczkowanie odpowiedzi da wykres inercji pierwszego rzędu, z którego należy odczytać stałą czasową i wzmocnienie układu.
Te parametry da się określić również z wykresu odpowiedzi drogi w czasie.
W celu ich określenia należy wykreślić prostą do wykresu odpowiedzi.
Punkt przecięcia prostej z osią \textsc{x} będzie określał stałą czasową układu, natomiast nachylenie prostej jego wzmocnienie.
Ponieważ układ przybliżamy transmitancją całki z inercją jego transmitancja będzie miała postać przedstawioną na wzorze \ref{eq:ob_int}.

\begin{equation} \label{eq:ob_int}
	K_{o1} \left( s \right) = \frac{k}{s \left( 1 + sT \right)}
\end{equation}
gdzie parametry stałej czasowej $ T $ i wzmocnienia $ k $, można obliczyć z dopasowanej do odpowiedzi prostej według wzorów \ref{eq:line_param}.

\begin{equation} \label{eq:line_param}
\begin{aligned}
	y(t) &= a \cdot t + b \\
	k &= a \\
	T &= - \frac{a}{b} \\
\end{aligned}
\end{equation}

Identyfikację układu i wykresy zostały wykonane w środowisku \textsc{matlab}, kod programu identyfikacyjnego przedstawia listing % TODO

\subsection{Strojenie regulatorów}
Ponieważ regulatory \textsc{PI} będą regulowały prędkość silników należy przekształcić odpowiedź tak by uzyskać wykres prędkości w czasie.
Uzyskana identyfikacja obiektu całkującego opisuje zmiany drogi w czasie, aby uzyskać transmitancję związaną ze zmianami prędkości należy zróżniczkować transmitancję obiektu całkującego przemnażając ją przez operator $ s $, co obrazują przekształcenia we wzorze \ref{eq:ob_inert}. Jak widać zmiany prędkości w czasie są opisane modelem inercyjnym.

\begin{equation} \label{eq:ob_inert}
	K_{o2} \left( s \right) = s \cdot K_{o1} \left( s \right) = s \cdot \frac{k}{s \left( 1 + sT \right)} = \frac{k}{s \left( 1 + sT \right)}
\end{equation}

Zdecydowano się na regulator \textsc{PI}, który ma wystarczający astatyzm, oraz jest łatwy w implementacji.
W przypadku naszego układu który opisujemy transmitancją niskiego rzędu odpowiednim sposobem strojenia będzie użycie lini pierwiastkowych.
W celu wykreślenia linii najlepiej zapisać transmitancję regulatora i obiekty w postaci zero-biegunowej, którą przedstawia wzór \ref{eq:reg_pi_casc}.

\begin{equation} \label{eq:reg_pi_casc}
	PI \left( s \right) \cdot K_{o2} \left( s \right) = \left( \frac{s + c}{s} \right) \cdot \frac{k}{s \left( 1 + sT \right)}
\end{equation}

Należy zdecydować o wartości dodanego zera $ c $. Jego stosunek do stałej czasowej $ T $ zdecyduje o~kształcie linii pierwiastkowych.
Można rozpatrzeć trzy przypadki:
\begin{itemize}
	\item zero większe do stałej czasowej $ c > T $,
	\item zero równe stałej czasowej $ c = T $
	\item zero mniejsze od stałej czasowej $ c < T $.
\end{itemize}
Przypadek równości tych parametrów jest najbardziej korzystny, doprowadzi do skrócenia fragmentów transmitancji, w takim wypadku regulator działałby jak korektor, a układ działałby najszybciej jak to możliwe.
Mimo tego jest to przypadek który należy odrzucić.
Aby osiągnąć równość parametrów należałoby przeprowadzić identyfikację o nieosiągalnej dokładności, jednak wyznaczona wartość stałej czasowej może i zapewne różni się od rzeczywistych parametrów układu.
Mało prawdopodobne jest zrealizowanie korektora, a dobór zera równego zidentyfikowanej stałej czasowej da w rzeczywistości niespodziewane rezultaty, ze względu na niedoskonałości procesu identyfikacji.
Należy rozpatrzyć pozostałe dwa przypadki, liniowe pierwiastkowe dla nich wykreślono na rysunku % TODO
Prędkość działania finalnego układu jest zdeterminowana przez położenie bieguna, który znajduje się najbliżej osi urojonej \textsc{y}.
Im bardziej od osi oddalony jest ten biegun tym szybszy układ.
Przy analizie linii pierwiastkowych należy również pamiętać, że położenia biegunów o niezerowej części urojonej oznaczają oscylacje układu.
Jak wspomniano w sekcji \ref{sec:err} zależy nam na konstrukcji układu aperiodycznego\footnote{tzn. bez oscylacji.}, czyli powinniśmy umieścić nasze bieguny na osi \textsc{x}.

Można zauważyć że przypadek $ c > T $ pozwala na zbudowanie szybszego regulatora.
W takiej konfiguracji, przy dużych wzmocnieniach najwolniejszy biegun znajduje się z lewej strony założonego zera, czyli dalej od osi urojonej \textsc{y}.
W konfiguracji $ c < T $ najwolniejszy biegun znajduje się po prawej stronie zera, czyli taki układ jest wolniejszy.
Przypadek $ c > T $ zdaje się bardziej korzystny, jednak niesie ze sobą ryzyko oscylacji.
Teoretycznie najlepsze położenie bieguna w tej konfiguracji to miejsce w którym pierwiastki wracają z koła wartości urojonych z powrotem na oś rzeczywistą \textsc{x}.
Jest to jednak lokacja ryzykowna ze względu na niedoskonałości identyfikacji.
Przez jej błędy możemy omyłkowo, w układzie rzeczywistym, ulokować bieguny z częścią urojoną czyli wprowadzić oscylacje.
Dla pewności wyeliminowania oscylacji należy zwiększyć wzmocnienie układu i umieścić pierwiastki dalej od koła wartości urojonych.
Wadą takiego rozwiązania jest spowolnienie układu przez zbliżenie bieguna do osi \textsc{y} oraz wymaganie dużego wzmocnienia, które może być niemożliwe dla układu realizującego algorytm sterowania i elementów wykonawczych.
Konfiguracja $ c < T $ może być praktycznie lepsza, niż mogło zdawać się pierwotnie nie niesie ryzyka oscylacji.
To że taka konfiguracja jest wolniejsza także niesie pewne zalety, mało gwałtowne ruchy robota minimalizują ryzyko poślizgów kół.
W celu nastrojenia układów regulacji należy wykonać eksperymenty i porównać oczekiwania wynikające z linii pierwiastkowych z rzeczywistością.

\section{Implementacja programistyczna}
\subsection{Podział i organizacja kodu}
Kod odpowiadający za różne funkcjonalności robota umieszczono w oddzielnych plikach, w których znajdują się funkcje budujące warstwy abstrakcji peryferiów konstrukcji. Zdecydowano się na następujący podział plików i funckjonalności:
\begin{itemize}
	\item \texttt{defines} zawiera stałe programu oraz makroinstrukcje,
	\item \texttt{servoSensor} zawiera funkcje budujące warstwę abstrakcji czujnika ultradźwiękowego na wieży serwomechanizmu, pozwala na kierowanie czujnika w różne strony, wykrywanie przeszkód oraz poszukiwanie wolnej drogi w otoczeniu,
	\item \texttt{platformMotors} zawiera funkcję budujące warstwę abstrakcji platformy robota, pozwala na jazdę na wprost oraz skręty, bazuje w działaniu na układach regulacji,
	\item \verb|HC_SR04| zawiera zmodyfikowaną bibliotekę obsługi czujnika ultradźwiękowego w trybie nieblokującym, biblioteka jest wykorzystywana przez funkcje z pliku \texttt{servoSensor},
	\item \texttt{main} zawiera główną logikę programu, wywołuje funkcje poszukiwań drogi bez przeszkód i podążania w tym kierunku, kontroluje także wyłączanie i włączanie układu po odebraniu rozkazów wysłanych podczerwienią.
\end{itemize}

\subsection{Algorytm omijania przeszkód}
Kluczowym elementem omijania przeszkód jest znajdywanie drogi na której nie znajdują się przeszkody.
Proces znajdywania nowego kierunku jazdy rozpoczyna się w momencie, w którym na obecnym kierunku jazdy zostaje wykryta przeszkoda.
Wtedy robot się zatrzymuje i losuje po której stronie najpierw będzie szukał wolnej drogi. Potem zwraca w~tym kierunku czujnik ultradźwiękowy i~wykrywa obecność przeszkód.
Jeżeli takie nie zostaną wykryte platforma skręca w~wylosowanym kierunku i~rozpoczyna jazdę na wprost.
W przeciwnym przypadku robot kieruje czujnik w drugą stronę i~bada czy tam znajduje się przeszkoda, jeżeli nie to rozpocznie jazdę w~tym kierunku.
Kiedy obie strony robota są zablokowane ten zwróci się w~kierunku z~którego przyjechał. Opisane zachowanie obrazuje schemat na rysunku % TODO

\subsection{Algorytmy regulacji}
\subsubsection{Algorytm regulacji synchronizacji prędkości silników}
Algorytm synchronizacji został zaprogramowany według schematu na rysunku % TODO
Kod realizujący założenia schematu przedstawiono na listingu \ref{lst:synch_reg}.
Parametry regulatora należy przekształcić względem tych uzyskanych z analizy linii pierwiastkowych, aby ułatwić obliczenia i czytelność kodu.
Formuła regulatora zastosowana w kodzie ma postać jak we wzorze \ref{eq:progr_PI}, gdzie:
\begin{itemize}
	\item $ \Delta \alpha $ to uchyb ilości zliczonych slotów,
	\item $ \Delta \omega $ to uchyb chwilowej prędkości,
\end{itemize}
Parametry regulatora w takiej postaci można wyliczyć według wzoru \ref{eq:reg_param}, gdzie:
\begin{itemize}
	\item $ k_r $ to wzmocnienie regulatora odczytane z linii pierwiastkowych,
	\item $ c $ to wartość zera transmitacnji ze wzoru \ref{eq:reg_pi_casc}.
\end{itemize}

\begin{equation} \label{eq:reg_param}
\begin{aligned}
	P &=  k_r\\
	I &=  k_r \cdot c\\
\end{aligned}
\end{equation}


\begin{equation} \label{eq:progr_PI}
	PI \left( \Delta \alpha, \Delta \omega \right) = P \cdot \Delta \alpha + I \cdot \Delta \omega
\end{equation}


\begin{listing}[htb]
\caption{Algorytm regulacji synchronizacji prędkości silników}
\inputminted[firstline=161, lastline=183, frame=lines, linenos, breaklines]{cpp}{../src/platformMotors.cpp}
\label{lst:synch_reg}
\end{listing}

\subsubsection{Algorytm regulacji skrętu o kąt zadany}
Algorytm regulacji skrętu o kąt zadany został zaprogramowany według schematu na rysunku % TODO
Kod pętli wewnątrz której realizowana jest regulacja przedstawiony jest na listingu \ref{lst:rot_reg}.
Wypracowanie sterowania rozpoczyna się od wyznaczenia uchybu ilości slotów wymaganych do wykonania obrotów.
Wartość zadana \texttt{target} regulatora położenia jest wyliczana z makrofunkcji realizującej wzór \ref{eq:slot_num}.
Wartość zadana prędkości została ograniczona aby zapobiec poślizgom.
Wartość zadana regulatora prędkości jest wypracowywana jest przez regulator położenia.
Różniczkowanie ilości slotów w celu otrzymania prędkości chwilowej zrealizowano przez dzielenie odwracanie czasu zliczonego między ostatnimi przerwaniami wygenerowanymi przez czujniki szczelinowe.
Kod przerwań czujników przedstawia listing \ref{lst:enc_int}
Istotne jest aby pamiętać o rzutowaniu wartości \texttt{int} na \texttt{figure} przy dzieleniu, aby zachować precyzję obliczeń.
Całkowanie uchybu odbywa się przez mnożenie go przez czas jaki upłynął od ostatniego przerwania czujnika szczelinowego.
W rozdziale \ref{sec:reg_casc} opisującym założenia budowy regulatora kaskadowego opisano założenia konstrukcji zerującej wartość całki przy każdym przerwaniu czujnika szczelinowego.
Odpowiednikiem tego założenia w kodzie jest brak zapamiętywania i sumowania poprzednich wartości całki, przy każdej nowej szczelinie czas od tego przerwania jest liczony od nowa.
Jest to bardzo uproszczona realizacja członu całkującego, jednak zupełnie wystarczająca w naszym przypadku\footnote{
	Działanie członu całkującego można sprawdzić w sposób eksperymentalny.
	W tym celu wyłączono człon proporcjonalny, zerując jego parametr \texttt{P}.
	Robot powinien na początku nie ruszyć, a wraz z brakiem jego ruchu powinien być nacałkowywany coraz większy uchyb i zadawane coraz większe wysterowanie silników.
	Po chwili powinien być słyszany odgłos silników próbujących pokonać opory ruchu.
	Ostatecznie wartość całki powinna być na tyle duża, że silniki ruszą i nastąpi obrót kół o kąt powodujący zliczenie jednej szczeliny.
	Ponieważ całkę zerujemy przy każdej zliczonej szczelinie robot się zatrzyma i zacznie całkować uchyb od nowa.
	Proces ten będzie powtarzał się aż robot wykona stopniowo pełen skręt.
	Przewidywania te potwierdził eksperyment.
}.


\begin{listing}[htbp]
\caption{Algorytm regulacji skrętu o kąt zadany}
\inputminted[firstline=85, lastline=126, frame=lines, linenos, breaklines, fontsize=\small ]{cpp}{../src/platformMotors.cpp}
\label{lst:rot_reg}
\end{listing}

\subsection{Kod funkcji obsługującej przerwanie czujnika szczelinowego}
Kod funkcji obsługującej przerwanie czujnika szczelinowego\footnote{Funkcje obsługi przerwań lewego i prawego czujnika należało napisać oddzielnie, ale ich kod jest praktycznie taki sam.
Opisano tu kod obsługi jednego czujnika, ale drugi różni się tylko operacjami na innych zmiennych globalnych, logika jego działania jest identyczna.} przedstawiono na listingu \ref{lst:enc_int}.
Funkcje obsługi przerwań czujników szczelinowych mają za zadanie inkrementację licznika szczelin oraz obliczenie czasu
W funkcji należało uwzględnić inne zachowanie przerwań przy początku ruchu robota.
Przy testach czujników okazało się, że przy zmianie stanu czujnika następuje zjawisko podobne do odbijania styków, co sprawiało że fałszywie zliczana była ogromna ilość szczelin.
Aby temu zapobiec ignorowane są sygnały które pojawiły się zbyt szybko względem ostatniej zmiany.
Tworząc kod przerwań należy pamiętać, że ich obsługa w mikrokontrolerach ATmega wyłącza działanie liczników przez co funkcje \texttt{millis()} w~przerwaniach zwracają czas włączenia przerwania, a~czas który upłynął na obsłudze przerwania jest pomijany przy następnych wywołaniach funkcji \texttt{millis()}.
To zjawisko mogłoby powodować błędy jeżeli zależałoby nam na precyzyjnym zliczaniu czasu od wydarzenia, kiedy podczas zliczania obsługujemy dużo przerwań o długim kodzie obsługi.
Taka potrzeba nie zachodzi jednak w naszym przypadku, więc użycie funkcji \texttt{millis()} jest bezpieczne.


\begin{listing}[htb]
\caption{Kod funkcji obsługującej przerwanie czujnika szczelinowego}
\inputminted[firstline=185, lastline=206, frame=lines, linenos, breaklines]{cpp}{../src/platformMotors.cpp}
\label{lst:enc_int}
\end{listing}

\section{Wykorzystane technologie}
\subsection{Narzędzia programistyczne}
Ze względu na ograniczenia programu Arduino IDE zdecydowano się na użycie środowiska PlatformIO, które jest wtyczką do programu Visual Studio Code. Taka konfiguracja oferuje:
\begin{itemize}
	\item bogate kolorowanie składni języków programowania,
	\item zaawansowany system autouzupełniania kodu z użyciem technologii \textit{IntelliSense},
	\item automatyczne wykrywanie portów szeregowych z podłączonymi płytkami,
	\item konstrukcja bazująca na plikach \textit{make} i programie \textsc{avrdude}.
\end{itemize}
Kod projektu wersjonowano z użyciem programu Git oraz korzystając z usług serwisu GitHub, który oferuje internetowy interfejs do zarządzania repozytorium, system \textit{issue tracking} oraz zarządzanie projektem za pomocą tablic kanban.

\subsection{Komunikacja z mikroprocesorem}
Do komunikacji z mikroprocesorem przydatny okazał się program \textsc{avrdude}. Szczególnie jego polecenia testu poprawnej komunikacji i odczytu \textit{fuse bitów}. Poniżej przedstawiono przykład użycia polecenia testu mikrokontrolera oraz jego wynik:

\begin{verbatim}
$ sudo avrdude -p m32u4 -c usbasp -P usb
avrdude: AVR device initialized and ready to accept instructions
Reading | ############################################### | 100% 0.01s
avrdude: Device signature = 0x1e9587
avrdude: safemode: Fuses OK
avrdude done.  Thank you.
\end{verbatim}
Polecenie odczytu \textit{fusebitów} ma z kolei następujący format i daje wynik:
\begin{verbatim}
$ sudo avrdude -p m32u4 -c usbasp -P usb -U hfuse:r:hfuse.hex:h
avrdude: AVR device initialized and ready to accept instructions
Reading | ############################################### | 100% 0.01s
avrdude: Device signature = 0x1e9587
avrdude: reading hfuse memory:
Reading | ############################################### | 100% 0.00s
avrdude: writing output file "hfuse.hex"
avrdude: safemode: Fuses OK
avrdude done.  Thank you.
\end{verbatim}
Jak widać w powyższych instrukcjach, do programowania mikrokontrolera użyto programatora USBasp.
Przy zakupie takiego programatora warto upewnić się że kupujemy wersję z najnowszym firmwarem, dzięki czemu programator będzie miał od razu dostępną funkcję automatycznego dopasowania do taktowania zegara mikrokontrolera.
Program Arduino IDE pozwala na wypalenie w pamięci mikrokontrolera bootloadera Arduino. Opcja ta jest dostępna w pasku menu w zakładce narzędzia.

\section{Perspektywy rozwoju, podsumowanie}
Wykonany projekt spełnił założenia, dzięki zastosowaniu układów regulacji napędu silników robot jest stanie poruszać się na tyle precyzyjnie by wymijać przeszkody.
Wszystkie elementy układu oraz części obwodu drukowanego działają w sposób poprawny.
Załączniki do dokumentacji zawierają materiały multimedialne prezentujące osiągniętą dokładność pracy robota.
Projekt miał charakter edukacyjny, jego wyników nie da się porównać z produktami komercyjnymi, jednak zdobyte podczas jego realizacji doświadczenie i fragmenty pracy mogą być przydatne przy konstrukcji robotów magazynowych, robotów labiryntowych oraz przy konstrukcji dedykowanych serwomechanizmów.

Precyzję układu można zwiększyć stosując tarcze enkoderów o większej ilości szczelin, lub stosując enkodery umieszczane przed przekładnią silników.
Ciekawą ścieżką rozwoju może być zamiana układu pomiarowego z enkodera badającego obroty kół na system Yaw, Pitch Roll. Jest to zestaw współpracujących ze sobą: żyroskopu, magnetometru oraz akcelerometru w celu ustalenia kierunku układu w przestrzeni poprzez kąty eulera.
Taki układ pomiarowy cechowałby się daleko większą dokładnością i obejmowałby pętlą sprzężenia zwrotnego nie tylko obroty silnika ale rzeczywisty kierunek robota, eliminując błędy związane z poślizgiem kół.
Na obecnym etapie projektu taki system pomiarowy znacząco przekroczyłby budżet, jednak w przyszłości może on stanowić ciekawe zagadnienie.
Jego wprowadzenie pozwoliłoby na zachowanie sporej ilości aktualnego kodu, zmiany wymagałby jedynie tor pomiarowy i zadajnik.

Na bieżącym etapie układ nie zapamiętuje ścieżki którą przebył, aby to zmienić można skonstruować drzewo binarne wykonanych zakrętów i odległości między nimi. Dzięki temu układ mógłby analizować przebytą drogę i szukać wyjścia z bardziej złożonych labiryntów.



\end{document}